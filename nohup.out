yarn run v1.21.1
warning package.json: No license field
$ ts-node-dev -r tsconfig-paths/register --inspect --transpileOnly --ignore-watch node_modules src/shared/infra/http/server.ts
Ignore watch: [ 'node_modules' ]
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/bad1bcdb-d3ba-45ca-8704-4ce9793969ea
For help, see: https://nodejs.org/en/docs/inspector
yarn run v1.21.1
warning package.json: No license field
$ ts-node-dev -r tsconfig-paths/register --inspect --transpileOnly --ignore-watch node_modules src/shared/infra/http/server.ts
Ignore watch: [ 'node_modules' ]
Using ts-node version 8.9.0, typescript version 3.8.3
Starting inspector on 127.0.0.1:9229 failed: address already in use
error Command failed with exit code 12.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
yarn run v1.21.1
warning package.json: No license field
$ ts-node-dev -r tsconfig-paths/register --inspect --transpileOnly --ignore-watch node_modules src/shared/infra/http/server.ts
Ignore watch: [ 'node_modules' ]
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/d0438325-c90b-4d5c-a517-dec72c86d30b
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
=========================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368488791
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368488791
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "40"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "40"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368488791
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368488791
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368488791
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368488791
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368488791
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "40"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "40"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368488791
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleiton.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleiton.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7986,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7986,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '40'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '40'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7986,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleiton.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
[INFO] 15:23:31 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/routes/password.routes.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/55621c40-3691-44a0-9081-d615a778d808
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
=========================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368622082
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368622082
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "40"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "40"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368622082
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368622082
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368622082
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368622082
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368622082
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "40"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "40"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368622082
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleiton.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleiton.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 9476,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 9476,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '40'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '40'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 41,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 9476,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 42,
        [Symbol(triggerId)]: 41
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleiton.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
[INFO] 15:24:44 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/infra/http/server.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/ddc08df2-b38f-4d4c-8637-f137d9415761
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
===============================================================
===============================================================
===============================================================
===============================================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368696735
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368696735
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "40"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "40"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368696735
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368696735
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368696735
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368696735
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368696735
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "40"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "40"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368696735
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleiton.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleiton.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 11230,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 11230,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '40'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '40'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 11230,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleiton.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
===============================================================
===============================================================
===============================================================
===============================================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368775588
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368775588
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "41"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "41"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368775588
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "41"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "41"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleitons.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "41"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "41"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleitons.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368775588
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "41"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "41"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleitons.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368775588
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368775588
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368775588
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "41"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "41"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368775588
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleitons.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleitons.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 127,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 90045,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 128,
        [Symbol(triggerId)]: 127
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 127,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 90045,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 128,
        [Symbol(triggerId)]: 127
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '41'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '41'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 127,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 90045,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 128,
        [Symbol(triggerId)]: 127
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleitons.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
===============================================================
===============================================================
===============================================================
===============================================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368795989
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368795989
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "40"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "40"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368795989
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368795989
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368795989
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368795989
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368795989
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "40"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "40"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368795989
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleiton.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleiton.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 159,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 110445,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 160,
        [Symbol(triggerId)]: 159
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 159,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 110445,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 160,
        [Symbol(triggerId)]: 159
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '40'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '40'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 159,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 110445,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 160,
        [Symbol(triggerId)]: 159
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleiton.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
[INFO] 15:27:33 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/infra/http/server.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/809c2f5f-70d4-4df1-b289-172a9e62cbcd
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:27:47 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/routes/password.routes.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/13d4dd05-cd8f-41a4-acf1-a46cfb159fa8
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
===============================================================
===============================================================
===============================================================
===============================================================
Error [ValidationError]: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": null,
    "pipesCount": 0,
    "flowing": true,
    "ended": true,
    "endEmitted": true,
    "reading": false,
    "sync": false,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "paused": false,
    "emitClose": true,
    "autoDestroy": false,
    "destroyed": false,
    "defaultEncoding": "utf8",
    "awaitDrain": 0,
    "readingMore": false,
    "decoder": null,
    "encoding": null
  },
  "readable": false,
  "_events": {
    "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.socket]",
          "connection": "[Circular ~.socket]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368875901
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.socket]",
      "connection": "[Circular ~.socket]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "connection": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "connection": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.connection]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.connection]",
          "connection": "[Circular ~.connection]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.connection.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368875901
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.connection]",
      "connection": "[Circular ~.connection]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.connection]",
        "connection": "[Circular ~.connection]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.connection]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.connection._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "headers": {
    "host": "127.0.0.1:3333",
    "user-agent": "insomnia/2020.2.2",
    "content-type": "application/json",
    "authorization": "Bearer ",
    "accept": "*/*",
    "content-length": "40"
  },
  "rawHeaders": [
    "Host",
    "127.0.0.1:3333",
    "User-Agent",
    "insomnia/2020.2.2",
    "Content-Type",
    "application/json",
    "Authorization",
    "Bearer ",
    "Accept",
    "*/*",
    "Content-Length",
    "40"
  ],
  "trailers": {},
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/password/forgot",
  "method": "POST",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": null,
      "pipesCount": 0,
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "paused": false,
      "emitClose": false,
      "autoDestroy": false,
      "destroyed": false,
      "defaultEncoding": "utf8",
      "awaitDrain": 0,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "readable": true,
    "_events": {
      "end": [
        function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
        function () { [native code] }
      ],
      "drain": [
        function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
      ],
      "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
      "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": true,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "bufferedRequest": null,
      "lastBufferedRequest": null,
      "pendingcb": 0,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": false,
      "bufferedRequestCount": 0,
      "corkedRequestsFree": {
        "next": null,
        "entry": null,
        "finish": function () { [native code] }
      }
    },
    "writable": true,
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
      },
      "_eventsCount": 2,
      "_connections": 1,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 120000,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 40000,
      "_connectionKey": "6::::3333"
    },
    "timeout": 120000,
    "parser": {
      "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
      "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
      "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
      "4": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "socket": "[Circular ~.client]",
          "connection": "[Circular ~.client]",
          "_header": null,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] },
      "parsingHeadersStart": 1593368875901
    },
    "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "socket": "[Circular ~.client]",
      "connection": "[Circular ~.client]",
      "_header": null,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": true,
          "endEmitted": true,
          "reading": false,
          "sync": false,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": true,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": false,
        "_events": {
          "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "connection": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "headers": {
          "host": "127.0.0.1:3333",
          "user-agent": "insomnia/2020.2.2",
          "content-type": "application/json",
          "authorization": "Bearer ",
          "accept": "*/*",
          "content-length": "40"
        },
        "rawHeaders": [
          "Host",
          "127.0.0.1:3333",
          "User-Agent",
          "insomnia/2020.2.2",
          "Content-Type",
          "application/json",
          "Authorization",
          "Bearer ",
          "Accept",
          "*/*",
          "Content-Length",
          "40"
        ],
        "trailers": {},
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/password/forgot",
        "method": "POST",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": true,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/password/forgot",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/password/forgot",
          "path": "/password/forgot",
          "href": "/password/forgot",
          "_raw": "/password/forgot"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {
          "email": "clleiton.silva@gmail.com"
        },
        "_body": true
      },
      "locals": {}
    }
  },
  "_consuming": true,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/password/forgot",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/password/forgot",
    "path": "/password/forgot",
    "href": "/password/forgot",
    "_raw": "/password/forgot"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "connection": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368875901
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "connection": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": false,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": true,
      "_events": {
        "end": [
          function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
          function () { [native code] }
        ],
        "drain": [
          function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
        ],
        "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
        "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": true,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "bufferedRequest": null,
        "lastBufferedRequest": null,
        "pendingcb": 0,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": false,
        "bufferedRequestCount": 0,
        "corkedRequestsFree": {
          "next": null,
          "entry": null,
          "finish": function () { [native code] }
        }
      },
      "writable": true,
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
        },
        "_eventsCount": 2,
        "_connections": 1,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 120000,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 40000,
        "_connectionKey": "6::::3333"
      },
      "timeout": 120000,
      "parser": {
        "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
        "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
        "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
        "4": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.connection]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": null,
            "pipesCount": 0,
            "flowing": true,
            "ended": true,
            "endEmitted": true,
            "reading": false,
            "sync": false,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "paused": false,
            "emitClose": true,
            "autoDestroy": false,
            "destroyed": false,
            "defaultEncoding": "utf8",
            "awaitDrain": 0,
            "readingMore": false,
            "decoder": null,
            "encoding": null
          },
          "readable": false,
          "_events": {
            "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.connection]",
          "connection": "[Circular ~.res.connection]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "headers": {
            "host": "127.0.0.1:3333",
            "user-agent": "insomnia/2020.2.2",
            "content-type": "application/json",
            "authorization": "Bearer ",
            "accept": "*/*",
            "content-length": "40"
          },
          "rawHeaders": [
            "Host",
            "127.0.0.1:3333",
            "User-Agent",
            "insomnia/2020.2.2",
            "Content-Type",
            "application/json",
            "Authorization",
            "Bearer ",
            "Accept",
            "*/*",
            "Content-Length",
            "40"
          ],
          "trailers": {},
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/password/forgot",
          "method": "POST",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.connection]",
          "_consuming": true,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/password/forgot",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/password/forgot",
            "path": "/password/forgot",
            "href": "/password/forgot",
            "_raw": "/password/forgot"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {
            "email": "clleiton.silva@gmail.com"
          },
          "_body": true
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] },
        "parsingHeadersStart": 1593368875901
      },
      "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]"
    },
    "_header": null,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": null,
        "pipesCount": 0,
        "flowing": true,
        "ended": true,
        "endEmitted": true,
        "reading": false,
        "sync": false,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "paused": false,
        "emitClose": true,
        "autoDestroy": false,
        "destroyed": false,
        "defaultEncoding": "utf8",
        "awaitDrain": 0,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "readable": false,
      "_events": {
        "end": function resetHeadersTimeoutOnReqEnd() {\n  debug('resetHeadersTimeoutOnReqEnd');\n\n  const parser = this.socket.parser;\n  // Parser can be null if the socket was destroyed\n  // in that case, there is nothing to do.\n  if (parser) {\n    parser.parsingHeadersStart = nowDate();\n  }\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368875901
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "connection": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.connection]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368875901
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "headers": {
        "host": "127.0.0.1:3333",
        "user-agent": "insomnia/2020.2.2",
        "content-type": "application/json",
        "authorization": "Bearer ",
        "accept": "*/*",
        "content-length": "40"
      },
      "rawHeaders": [
        "Host",
        "127.0.0.1:3333",
        "User-Agent",
        "insomnia/2020.2.2",
        "Content-Type",
        "application/json",
        "Authorization",
        "Bearer ",
        "Accept",
        "*/*",
        "Content-Length",
        "40"
      ],
      "trailers": {},
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/password/forgot",
      "method": "POST",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": null,
          "pipesCount": 0,
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "paused": false,
          "emitClose": false,
          "autoDestroy": false,
          "destroyed": false,
          "defaultEncoding": "utf8",
          "awaitDrain": 0,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "readable": true,
        "_events": {
          "end": [
            function onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n\n  if (!this.destroyed && !this.writable && !this.writableLength)\n    this.destroy();\n},
            function () { [native code] }
          ],
          "drain": [
            function ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout', this);\n  const serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', noop);\n\n  if (!this.server.emit('clientError', e, this)) {\n    if (this.writable) {\n      const response = e.code === 'HPE_HEADER_OVERFLOW' ?\n        requestHeaderFieldsTooLargeResponse : badRequestResponse;\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}
          ],
          "resume": function onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n},
          "pause": function onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": true,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "bufferedRequest": null,
          "lastBufferedRequest": null,
          "pendingcb": 0,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": false,
          "bufferedRequestCount": 0,
          "corkedRequestsFree": {
            "next": null,
            "entry": null,
            "finish": function () { [native code] }
          }
        },
        "writable": true,
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\n  );\n}
          },
          "_eventsCount": 2,
          "_connections": 1,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 120000,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 40000,
          "_connectionKey": "6::::3333"
        },
        "timeout": 120000,
        "parser": {
          "0": function parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n},
          "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming, shouldKeepAlive);\n},
          "2": function parserOnBody(b, start, len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed, then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n},
          "3": function parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n},
          "4": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] },
          "parsingHeadersStart": 1593368875901
        },
        "on": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "addListener": function socketOnWrap(ev, fn) {\n  const res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.prependListener = net.Socket.prototype.prependListener;\n    this.on = net.Socket.prototype.on;\n    this.addListener = this.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]"
      },
      "_consuming": true,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/password/forgot",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/password/forgot",
        "path": "/password/forgot",
        "href": "/password/forgot",
        "_raw": "/password/forgot"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {
        "email": "clleiton.silva@gmail.com"
      },
      "_body": true
    },
    "locals": {}
  },
  "body": {
    "email": "clleiton.silva@gmail.com"
  },
  "_body": true,
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
    at Object.exports.process (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/errors.js:184:16)
    at Object.internals.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:140:26)
    at Object.exports.entry (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/validator.js:26:30)
    at internals.Base.validate (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/base.js:534:26)
    at Object.internals.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:225:27)
    at Object.assert (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/@hapi/joi/lib/index.js:102:19)
    at exports.errors (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/celebrate/lib/index.js:150:7)
    at newFn (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express-async-errors/index.js:16:20)
    at Layer.handle [as handle_request] (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/layer.js:95:5)
    at trim_prefix (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/express/lib/router/index.js:317:13) {
  _original: {
    statusCode: null,
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: true,
      endEmitted: true,
      reading: false,
      sync: false,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      paused: false,
      emitClose: true,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrain: 0,
      readingMore: false,
      decoder: null,
      encoding: null
    },
    readable: false,
    _events: [Object: null prototype] {
      end: [Function: resetHeadersTimeoutOnReqEnd]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    socket: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7836,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    connection: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7836,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    httpVersionMajor: 1,
    httpVersionMinor: 1,
    httpVersion: '1.1',
    complete: true,
    headers: {
      host: '127.0.0.1:3333',
      'user-agent': 'insomnia/2020.2.2',
      'content-type': 'application/json',
      authorization: 'Bearer ',
      accept: '*/*',
      'content-length': '40'
    },
    rawHeaders: [
      'Host',
      '127.0.0.1:3333',
      'User-Agent',
      'insomnia/2020.2.2',
      'Content-Type',
      'application/json',
      'Authorization',
      'Bearer ',
      'Accept',
      '*/*',
      'Content-Length',
      '40'
    ],
    trailers: {},
    rawTrailers: [],
    aborted: false,
    upgrade: false,
    url: '/password/forgot',
    method: 'POST',
    statusMessage: null,
    client: Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: [ReadableState],
      readable: true,
      _events: [Object: null prototype],
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: [Server],
      _server: [Server],
      timeout: 120000,
      parser: [HTTPParser],
      on: [Function: socketOnWrap],
      addListener: [Function: socketOnWrap],
      _paused: false,
      _httpMessage: [ServerResponse],
      [Symbol(asyncId)]: 40,
      [Symbol(kHandle)]: [TCP],
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: Timeout {
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 7836,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(refed)]: false,
        [Symbol(asyncId)]: 41,
        [Symbol(triggerId)]: 40
      },
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    _consuming: true,
    _dumped: false,
    next: [Function: next],
    baseUrl: '',
    originalUrl: '/password/forgot',
    _parsedUrl: Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: '/password/forgot',
      path: '/password/forgot',
      href: '/password/forgot',
      _raw: '/password/forgot'
    },
    params: {},
    query: {},
    res: ServerResponse {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: '',
      finished: false,
      _headerSent: false,
      socket: [Socket],
      connection: [Socket],
      _header: null,
      _onPendingData: [Function: bound updateOutgoingData],
      _sent100: false,
      _expect_continue: false,
      req: [IncomingMessage],
      locals: [Object: null prototype] {},
      [Symbol(isCorked)]: false,
      [Symbol(outHeadersKey)]: [Object: null prototype]
    },
    body: { email: 'clleiton.silva@gmail.com' },
    _body: true,
    length: undefined
  },
  details: [
    {
      message: '"statusCode" must be one of [400, 401, 402, 403, 404, 405, ' +
        '406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, ' +
        '418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, ' +
        '501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]',
      path: [Array],
      type: 'any.only',
      context: [Object]
    }
  ]
}
[INFO] 15:31:24 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/routes/password.routes.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/43167e8b-c406-4750-95eb-212097ba6c29
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
clleiton.silva@gmail.com
===============================================================
===============================================================
===============================================================
===============================================================
Error: Cannot inject the dependency at position #0 of "SendForgotEmailService" constructor. Reason:
    No repository for "User" was found. Looks like this entity is not registered in current "default" connection?
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/tsyringe/dist/cjs/dependency-container.js:209:23
    at Array.map (<anonymous>)
    at InternalDependencyContainer.construct (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/tsyringe/dist/cjs/dependency-container.js:195:34)
    at InternalDependencyContainer.resolve (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/tsyringe/dist/cjs/dependency-container.js:81:25)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts:10:44
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts:4:12)
[INFO] 15:35:09 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/routes/password.routes.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/24ec1c9c-654c-42b4-9c3a-14aa96ae6d7f
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:35:24 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/routes/password.routes.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/70af6e67-bff6-43ce-b131-3dbf9212c5c9
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
clleiton.silva@gmail.com
ta dificl
clleiton.silva@gmail.com
Repository {
  manager: EntityManager {
    repositories: [ [Circular] ],
    plainObjectToEntityTransformer: PlainObjectToNewEntityTransformer {},
    connection: Connection {
      migrations: [Array],
      subscribers: [],
      entityMetadatas: [Array],
      name: 'default',
      options: [Object],
      logger: [AdvancedConsoleLogger],
      driver: [PostgresDriver],
      manager: [Circular],
      namingStrategy: DefaultNamingStrategy {},
      queryResultCache: undefined,
      relationLoader: [RelationLoader],
      relationIdLoader: [RelationIdLoader],
      isConnected: true
    }
  },
  metadata: EntityMetadata {
    childEntityMetadatas: [],
    inheritanceTree: [ [Function: User] ],
    tableType: 'regular',
    withoutRowid: false,
    synchronize: true,
    hasNonNullableRelations: false,
    isJunction: false,
    isClosureJunction: false,
    hasMultiplePrimaryKeys: false,
    hasUUIDGeneratedColumns: true,
    ownColumns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    columns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    ancestorColumns: [],
    descendantColumns: [],
    nonVirtualColumns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    ownerColumns: [],
    inverseColumns: [],
    generatedColumns: [ [ColumnMetadata] ],
    primaryColumns: [ [ColumnMetadata] ],
    ownRelations: [],
    relations: [],
    eagerRelations: [],
    lazyRelations: [],
    oneToOneRelations: [],
    ownerOneToOneRelations: [],
    oneToManyRelations: [],
    manyToOneRelations: [],
    manyToManyRelations: [],
    ownerManyToManyRelations: [],
    relationsWithJoinColumns: [],
    relationIds: [],
    relationCounts: [],
    foreignKeys: [],
    embeddeds: [],
    allEmbeddeds: [],
    ownIndices: [],
    indices: [],
    uniques: [],
    ownUniques: [],
    checks: [],
    exclusions: [],
    ownListeners: [],
    listeners: [],
    afterLoadListeners: [],
    beforeInsertListeners: [],
    afterInsertListeners: [],
    beforeUpdateListeners: [],
    afterUpdateListeners: [],
    beforeRemoveListeners: [],
    afterRemoveListeners: [],
    connection: Connection {
      migrations: [Array],
      subscribers: [],
      entityMetadatas: [Array],
      name: 'default',
      options: [Object],
      logger: [AdvancedConsoleLogger],
      driver: [PostgresDriver],
      manager: [EntityManager],
      namingStrategy: DefaultNamingStrategy {},
      queryResultCache: undefined,
      relationLoader: [RelationLoader],
      relationIdLoader: [RelationIdLoader],
      isConnected: true
    },
    inheritancePattern: undefined,
    treeType: undefined,
    parentClosureEntityMetadata: undefined,
    tableMetadataArgs: {
      target: [Function: User],
      name: 'users_v2',
      type: 'regular',
      orderBy: undefined,
      engine: undefined,
      database: undefined,
      schema: undefined,
      synchronize: undefined,
      withoutRowid: undefined
    },
    target: [Function: User],
    expression: undefined,
    engine: undefined,
    database: undefined,
    schema: undefined,
    givenTableName: 'users_v2',
    targetName: 'User',
    tableNameWithoutPrefix: 'users_v2',
    tableName: 'users_v2',
    name: 'User',
    tablePath: 'users_v2',
    schemaPath: undefined,
    orderBy: undefined,
    discriminatorValue: 'User',
    treeParentRelation: undefined,
    treeChildrenRelation: undefined,
    createDateColumn: undefined,
    updateDateColumn: undefined,
    deleteDateColumn: undefined,
    versionColumn: undefined,
    discriminatorColumn: undefined,
    treeLevelColumn: undefined,
    nestedSetLeftColumn: undefined,
    nestedSetRightColumn: undefined,
    materializedPathColumn: undefined,
    objectIdColumn: undefined,
    propertiesMap: {
      id: 'id',
      name: 'name',
      email: 'email',
      password: 'password',
      avatar: 'avatar',
      created_at: 'created_at',
      updated_at: 'updated_at'
    }
  },
  queryRunner: undefined
}
passou aqui
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:24:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:36:27 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/7c361ba0-f78f-4bdc-9962-e052ed061360
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
email clleiton.silva@gmail.com
ta dificl
clleiton.silva@gmail.com
Repository {
  manager: EntityManager {
    repositories: [ [Circular] ],
    plainObjectToEntityTransformer: PlainObjectToNewEntityTransformer {},
    connection: Connection {
      migrations: [Array],
      subscribers: [],
      entityMetadatas: [Array],
      name: 'default',
      options: [Object],
      logger: [AdvancedConsoleLogger],
      driver: [PostgresDriver],
      manager: [Circular],
      namingStrategy: DefaultNamingStrategy {},
      queryResultCache: undefined,
      relationLoader: [RelationLoader],
      relationIdLoader: [RelationIdLoader],
      isConnected: true
    }
  },
  metadata: EntityMetadata {
    childEntityMetadatas: [],
    inheritanceTree: [ [Function: User] ],
    tableType: 'regular',
    withoutRowid: false,
    synchronize: true,
    hasNonNullableRelations: false,
    isJunction: false,
    isClosureJunction: false,
    hasMultiplePrimaryKeys: false,
    hasUUIDGeneratedColumns: true,
    ownColumns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    columns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    ancestorColumns: [],
    descendantColumns: [],
    nonVirtualColumns: [
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata],
      [ColumnMetadata]
    ],
    ownerColumns: [],
    inverseColumns: [],
    generatedColumns: [ [ColumnMetadata] ],
    primaryColumns: [ [ColumnMetadata] ],
    ownRelations: [],
    relations: [],
    eagerRelations: [],
    lazyRelations: [],
    oneToOneRelations: [],
    ownerOneToOneRelations: [],
    oneToManyRelations: [],
    manyToOneRelations: [],
    manyToManyRelations: [],
    ownerManyToManyRelations: [],
    relationsWithJoinColumns: [],
    relationIds: [],
    relationCounts: [],
    foreignKeys: [],
    embeddeds: [],
    allEmbeddeds: [],
    ownIndices: [],
    indices: [],
    uniques: [],
    ownUniques: [],
    checks: [],
    exclusions: [],
    ownListeners: [],
    listeners: [],
    afterLoadListeners: [],
    beforeInsertListeners: [],
    afterInsertListeners: [],
    beforeUpdateListeners: [],
    afterUpdateListeners: [],
    beforeRemoveListeners: [],
    afterRemoveListeners: [],
    connection: Connection {
      migrations: [Array],
      subscribers: [],
      entityMetadatas: [Array],
      name: 'default',
      options: [Object],
      logger: [AdvancedConsoleLogger],
      driver: [PostgresDriver],
      manager: [EntityManager],
      namingStrategy: DefaultNamingStrategy {},
      queryResultCache: undefined,
      relationLoader: [RelationLoader],
      relationIdLoader: [RelationIdLoader],
      isConnected: true
    },
    inheritancePattern: undefined,
    treeType: undefined,
    parentClosureEntityMetadata: undefined,
    tableMetadataArgs: {
      target: [Function: User],
      name: 'users_v2',
      type: 'regular',
      orderBy: undefined,
      engine: undefined,
      database: undefined,
      schema: undefined,
      synchronize: undefined,
      withoutRowid: undefined
    },
    target: [Function: User],
    expression: undefined,
    engine: undefined,
    database: undefined,
    schema: undefined,
    givenTableName: 'users_v2',
    targetName: 'User',
    tableNameWithoutPrefix: 'users_v2',
    tableName: 'users_v2',
    name: 'User',
    tablePath: 'users_v2',
    schemaPath: undefined,
    orderBy: undefined,
    discriminatorValue: 'User',
    treeParentRelation: undefined,
    treeChildrenRelation: undefined,
    createDateColumn: undefined,
    updateDateColumn: undefined,
    deleteDateColumn: undefined,
    versionColumn: undefined,
    discriminatorColumn: undefined,
    treeLevelColumn: undefined,
    nestedSetLeftColumn: undefined,
    nestedSetRightColumn: undefined,
    materializedPathColumn: undefined,
    objectIdColumn: undefined,
    propertiesMap: {
      id: 'id',
      name: 'name',
      email: 'email',
      password: 'password',
      avatar: 'avatar',
      created_at: 'created_at',
      updated_at: 'updated_at'
    }
  },
  queryRunner: undefined
}
passou aqui
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:24:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:37:03 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/http/controllers/ForgotPasswordController.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/bd4839d8-6de6-44ba-bdd8-d9f8164c6bad
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:38:31 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/d7246f33-fcf0-45a9-b55e-05cf1a968e4b
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
passou aqui: [object Object]
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:24:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:39:01 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/a8eff4cb-ab3c-4c2d-b049-c0198e40ab24
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
passou aqui: [object Object]
User {
  id: '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0',
  name: 'Cleiton Silva',
  email: 'clleiton.silva@gmail.com',
  password: '$2b$08$XT8Josa94MVwAKVKtJXoyu76XhK2Ow/RGQ.fvhUoQP4rg7HPpmr5W',
  avatar: null,
  created_at: 2020-06-28T21:00:07.320Z,
  updated_at: 2020-06-28T21:00:07.320Z
}
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:24:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:39:24 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/22dbeef0-0f2e-4e10-9709-48a22d8271a1
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:40:28 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/2dcfebe3-77dc-4624-9937-f7b883536bd2
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:24:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:42:00 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/8b619ee0-8a1b-40d9-a6b0-5802cd98bf42
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:26:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:42:30 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/f2569570-55e8-4734-8b3d-e01fdba3f501
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:26:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:42:58 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/48f4c840-ddb6-44bc-883e-1c06976d86bb
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:43:56 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/3b158cda-faa9-41fb-89d1-98895c5ce76e
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:26:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:44:29 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/9f5daf0b-05a9-4630-9679-8d234727d88b
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0
===============================================================
===============================================================
===============================================================
===============================================================
TypeError: Cannot read property 'create' of undefined
    at UserTokenRepository.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:26:48)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:4:12)
    at UserTokenRepository.generate (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts:66:16)
    at SendForgotEmailService.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:35:52)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:45:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts:26:53)
[INFO] 15:47:04 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/dd83a616-dd91-4828-aca4-94e914dca6de
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0
step 1.2
===============================================================
===============================================================
===============================================================
===============================================================
QueryFailedError: null value in column "id" violates not-null constraint
    at new QueryFailedError (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/error/QueryFailedError.ts:9:9)
    at Query.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/driver/postgres/PostgresQueryRunner.ts:178:30)
    at Query.handleError (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/query.js:146:19)
    at Connection.connectedErrorMessageHandler (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/client.js:233:17)
    at Connection.emit (events.js:200:13)
    at Connection.EventEmitter.emit (domain.js:471:20)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/connection.js:109:10
    at Parser.parse (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg-protocol/src/parser.ts:107:9)
    at Socket.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg-protocol/src/index.ts:7:48)
    at Socket.emit (events.js:200:13) {
  message: 'null value in column "id" violates not-null constraint',
  length: 271,
  name: 'QueryFailedError',
  severity: 'ERROR',
  code: '23502',
  detail: 'Failing row contains (null, null, ' +
    '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0, 2020-06-28 ' +
    '18:47:10.466906, 2020-06-28 18:47:10.466906).',
  hint: undefined,
  position: undefined,
  internalPosition: undefined,
  internalQuery: undefined,
  where: undefined,
  schema: 'public',
  table: 'user_token',
  column: 'id',
  dataType: undefined,
  constraint: undefined,
  file: 'execMain.c',
  line: '1965',
  routine: 'ExecConstraints',
  query: 'INSERT INTO "user_token"("id", "token", "user_id", ' +
    '"created_at", "updated_at") VALUES (DEFAULT, ' +
    'DEFAULT, $1, DEFAULT, DEFAULT) RETURNING "id", ' +
    '"token"',
  parameters: [ '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0' ]
}
[INFO] 15:49:31 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/4456212d-d96f-4bb5-b86f-95866c15a58a
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:49:41 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/d537f4d7-be82-4b0b-ae0a-c695fe8c8211
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
step 1.2
UserToken { user_id: '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0' }
===============================================================
===============================================================
===============================================================
===============================================================
QueryFailedError: null value in column "id" violates not-null constraint
    at new QueryFailedError (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/error/QueryFailedError.ts:9:9)
    at Query.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/driver/postgres/PostgresQueryRunner.ts:178:30)
    at Query.handleError (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/query.js:146:19)
    at Connection.connectedErrorMessageHandler (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/client.js:233:17)
    at Connection.emit (events.js:200:13)
    at Connection.EventEmitter.emit (domain.js:471:20)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg/lib/connection.js:109:10
    at Parser.parse (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg-protocol/src/parser.ts:107:9)
    at Socket.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/pg-protocol/src/index.ts:7:48)
    at Socket.emit (events.js:200:13) {
  message: 'null value in column "id" violates not-null constraint',
  length: 271,
  name: 'QueryFailedError',
  severity: 'ERROR',
  code: '23502',
  detail: 'Failing row contains (null, null, ' +
    '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0, 2020-06-28 ' +
    '18:49:46.986483, 2020-06-28 18:49:46.986483).',
  hint: undefined,
  position: undefined,
  internalPosition: undefined,
  internalQuery: undefined,
  where: undefined,
  schema: 'public',
  table: 'user_token',
  column: 'id',
  dataType: undefined,
  constraint: undefined,
  file: 'execMain.c',
  line: '1965',
  routine: 'ExecConstraints',
  query: 'INSERT INTO "user_token"("id", "token", "user_id", ' +
    '"created_at", "updated_at") VALUES (DEFAULT, ' +
    'DEFAULT, $1, DEFAULT, DEFAULT) RETURNING "id", ' +
    '"token"',
  parameters: [ '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0' ]
}
[INFO] 15:52:22 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/infra/typeorm/migrations/1591573270930-createUserTokenTable.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/cde3acd3-c45c-49f2-bc05-57c58bd18f11
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
yarn run v1.21.1
warning package.json: No license field
$ ts-node-dev -r tsconfig-paths/register --inspect --transpileOnly --ignore-watch node_modules src/shared/infra/http/server.ts
Ignore watch: [ 'node_modules' ]
Using ts-node version 8.9.0, typescript version 3.8.3
Starting inspector on 127.0.0.1:9229 failed: address already in use
error Command failed with exit code 12.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
yarn run v1.21.1
warning package.json: No license field
$ ts-node-dev -r tsconfig-paths/register --inspect --transpileOnly --ignore-watch node_modules src/shared/infra/http/server.ts
Ignore watch: [ 'node_modules' ]
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/5817f6c6-e2dd-417a-9a3c-32b831abbdae
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:56:26 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/b4b7644b-0b6d-437f-b8cb-dbd5dd7b680a
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 1
step 1.1
step 1.2
UserToken { user_id: '96c9e11f-c3f2-4f41-9a20-74f42d3d4cb0' }
step 1.3
step 2
step 3
===============================================================
===============================================================
===============================================================
===============================================================
TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "uft-8" is invalid for option "encoding"
    at assertEncoding (internal/fs/utils.js:69:11)
    at getOptions (internal/fs/utils.js:191:5)
    at Object.readFile (internal/fs/promises.js:464:13)
    at HandleBarsMailTemplateProvider.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:10:51)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:4:12)
    at HandleBarsMailTemplateProvider.parse (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:49:16)
[INFO] 15:57:08 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/infra/typeorm/repositories/UserTokenRepository.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/9ba4541f-4c63-4699-bfdd-9e2df08e8323
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
[INFO] 15:57:23 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/modules/users/services/SendForgotEmailService.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/292fe114-451f-44ff-8b74-20caae42cca2
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 3
===============================================================
===============================================================
===============================================================
===============================================================
TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "uft-8" is invalid for option "encoding"
    at assertEncoding (internal/fs/utils.js:69:11)
    at getOptions (internal/fs/utils.js:191:5)
    at Object.readFile (internal/fs/promises.js:464:13)
    at HandleBarsMailTemplateProvider.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:10:51)
    at step (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:33:23)
    at Object.next (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:14:53)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:4:12)
    at HandleBarsMailTemplateProvider.parse (/Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts:49:16)
[INFO] 15:59:35 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/MailTemplateProvider/implementations/HandleBarsMailTemplateProvider.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/ed8260fc-058d-4136-a4ab-dd3aaccdc3d0
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
step 3
step 4
(node:13523) UnhandledPromiseRejectionWarning: MessageRejected: Email address is not verified. The following identities failed the check in region US-EAST-1: clleiton.silva@gmail.com
    at Request.extractError (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/protocol/query.js:50:29)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:106:20)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:78:10)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:688:14)
    at Request.transition (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:22:10)
    at AcceptorStateMachine.runTo (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:14:12)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:26:10
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:38:9)
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:690:12)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:116:18)
(node:13523) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node:13523) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
step 3
step 4
step 3
step 4
step 3
step 4
(node:13523) UnhandledPromiseRejectionWarning: MessageRejected: Email address is not verified. The following identities failed the check in region US-EAST-1: van.antiopa@gmail.com
    at Request.extractError (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/protocol/query.js:50:29)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:106:20)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:78:10)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:688:14)
    at Request.transition (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:22:10)
    at AcceptorStateMachine.runTo (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:14:12)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:26:10
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:38:9)
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:690:12)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:116:18)
(node:13523) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 2)
step 3
step 4
(node:13523) UnhandledPromiseRejectionWarning: MessageRejected: Email address is not verified. The following identities failed the check in region US-EAST-1: clleiton.silva@gmail.com
    at Request.extractError (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/protocol/query.js:50:29)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:106:20)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:78:10)
    at Request.emit (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:688:14)
    at Request.transition (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:22:10)
    at AcceptorStateMachine.runTo (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:14:12)
    at /Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/state_machine.js:26:10
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:38:9)
    at Request.<anonymous> (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/request.js:690:12)
    at Request.callListeners (/Users/denver/Documents/projects/rocketseat/gobarberv2/node_modules/aws-sdk/lib/sequential_executor.js:116:18)
(node:13523) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 3)
step 3
step 4
step 3
step 4
[INFO] 23:26:15 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/index.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/0c6adf00-b4e1-4790-8b9d-bc254e8c9cc9
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
(node:19799) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:5432
    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1054:14)
(node:19799) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node:19799) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[INFO] 23:26:25 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/index.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/14007d63-c758-4c20-98fd-11516077b91b
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
(node:19811) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:5432
    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1054:14)
(node:19811) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node:19811) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[INFO] 23:27:06 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/index.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/d37d872d-b867-4d38-ba4a-e813e031784f
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
(node:19831) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:5432
    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1054:14)
(node:19831) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node:19831) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[INFO] 23:28:45 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/index.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/4008604b-16ff-4261-91a5-3b8e2be41e83
For help, see: https://nodejs.org/en/docs/inspector
servidor iniciado na porta 3333
(node:19952) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:5432
    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1054:14)
(node:19952) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node:19952) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[INFO] 23:30:44 Restarting: /Users/denver/Documents/projects/rocketseat/gobarberv2/src/shared/container/providers/index.ts has been modified
Using ts-node version 8.9.0, typescript version 3.8.3
Debugger listening on ws://127.0.0.1:9229/12591432-b59a-404f-8c76-ab5a00d3f888
For help, see: https://nodejs.org/en/docs/inspector
